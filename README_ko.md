<h1 align="center">GitHub Copilot으로 Python 프로젝트 업그레이드하기</h1>
<h5 align="center">레거시 코드에서 최신 안정 버전으로의 복잡한 업그레이드 수행</h3>

<p align="center">
  <a href="#mega-사전-요구사항">사전 요구사항</a> •
  <a href="#books-리소스">리소스</a> •
  <a href="#학습-목표">학습 목표</a>
</p>

- **대상자**: 레거시 코드의 까다로운 업그레이드 시나리오를 수행하기 위해 GitHub Copilot과 함께 AI 페어 프로그래밍 기술을 적용하려는 모든 기술자
- **학습 내용**: 프로젝트 업그레이드 시 특히 유용한 고급 GitHub Copilot 기법을 배우게 됩니다. 이러한 기법과 패턴은 업그레이드 및 리팩토링뿐만 아니라 처음부터 개발할 때도 적용할 수 있습니다.
- **구축할 것**: Python 2.5를 사용하고 레거시 및 사용 중단된 구문을 포함한 Python 프로젝트를 사용 가능한 최신 Python 3 버전으로 완전히 개선된 프로젝트

> [!NOTE]
> 워크샵을 찾고 계신가요? [워크샵 디렉토리](./workshop)로 이동하세요

## 학습 목표

이 워크샵에서 다음을 배우게 됩니다:

  - 레거시 프로젝트를 다루기 위한 고급 GitHub Copilot 상호작용 기법 사용
  - 레거시 프로젝트를 업그레이드하고 정확성을 검증하기 위한 답변 반복, 검증 및 개선
  - 제안을 개선하고 더 나은 결과를 얻을 수 있는 다양한 전략을 선택할 수 있는 일반적인 개념 적용
  - 잠재적인 문제를 식별하고 업그레이드 후 최종 상태에서 프로젝트를 검증하는 데 도움이 되는 철저한 테스트 전략 구축

## :mega: 사전 요구사항

워크샵에 참여하기 전에 사전 요구사항은 단 하나입니다: 공개 GitHub 계정이 있어야 합니다. 모든 리소스, 종속성 및 데이터는 리포지토리 자체의 일부입니다. GitHub Copilot 라이선스, 체험판 또는 무료 버전이 있는지 확인하세요.

## 주요 요점

### 1. 명확한 목표와 요구사항 정의

*무엇을 달성해야 하는가?*

종료 목표를 명확히 이해하는 것부터 시작하세요. 추구하는 결과는 무엇인가요? 레거시 프로젝트를 업그레이드할 때는 중요한 변경 사항을 만들 때 정확성과 완성도를 검증할 수 있는 철저한 테스트 전략을 보장해야 합니다.

*제약 사항은 무엇인가?*

제한 사항이나 배제 사항을 식별하세요. 예를 들어, 대형 언어 모델(LLM)은 올바른 제안을 제공하기에 충분한 맥락을 가지고 있을 수도 있고 없을 수도 있습니다. 목표를 달성하는 결정을 내리는 것은 운전자인 당신에게 달려 있습니다. 특정 비즈니스 로직으로 인해 다른 외부 라이브러리나 기능을 추가하지 못할 수 있습니다. 예를 들어, 프로덕션 환경에서 사용되는 프로젝트를 업그레이드하는 경우 기존 코드를 깨뜨릴 수 있는 새로운 라이브러리나 기능을 추가하지 못할 수 있습니다.

> [!TIP]
> 문제의 범위를 정확히 하는 데 집중하세요. 확실하지 않다면 광범위하게 시작한 다음 점진적으로 세부 사항을 좁혀나가세요.

### 2. 문제를 구성 요소로 분해

문제를 더 작고 관리 가능한 조각으로 분해하세요. 예를 들어, 핵심 애플리케이션 구성 요소부터 시작한 다음 단일 API 엔드포인트나 라이브러리 함수를 테스트하세요. 이렇게 하면 문제를 단계별로 이해하고 해결하기가 더 쉬워집니다:

- 단일 공개, 노출된 함수 또는 API 엔드포인트
- 테스트, 테스트 설정 및 검증 스크립트
- 구성 및 설치 프로세스

각 조건을 단계별로 적용하고 있는지 확인하세요. 프로그래밍에서 복잡한 함수를 더 작은 도우미 함수로 분해하면 작성과 디버깅이 더 쉬워질 수 있습니다.

> [!TIP]
> 분해는 복잡성을 다루는 좋은 방법입니다. 한 번에 하나의 작은 작업에 집중할 수 있게 해줍니다.

### 3. 작업 슬라이스 생성

작업 슬라이스는 전체 문제의 작고 관리 가능한 부분입니다. 이는 문제를 구성 요소로 분해하는 것과 유사하지만 완료해야 하는 특정 작업에 초점을 맞춥니다. 이를 특정 기능이나 기능성을 검증하는 기능 테스트와 같다고 생각하세요. 예를 들어, 레거시 프로젝트를 업그레이드하는 경우 단일 라이브러리나 함수 업그레이드에 초점을 맞춘 작업 슬라이스를 만들 수 있습니다.
이를 통해 한 번에 하나의 작은 작업에 집중할 수 있으며 변경 사항을 테스트하고 검증하기가 더 쉬워집니다.

> [!TIP]
> 작업 슬라이스를 만들 때 변경 사항을 쉽게 테스트할 수 있는 방법을 갖도록 기능 테스트를 고려하세요. 이는 변경 사항을 검증하는 테스트 스크립트를 만들거나 프로젝트의 모든 테스트를 실행하는 테스트 스위트를 만드는 것처럼 간단할 수 있습니다.

### 4. 솔루션 반복 및 개선
단순하게 시작한 다음 개선하세요. 복잡한 문제에서 초기 시도가 완벽한 경우는 드뭅니다. 기본 솔루션을 생성하는 것부터 시작하여 점진적으로 구축하세요.

> [!TIP]
> 매 반복마다 예상 결과와 대조하여 테스트하고 검증하여 결과가 올바른 방향으로 움직이고 있는지 확인하세요.

### 5. 예제를 사용하여 요구사항 명확화
AI 모델용 프롬프트를 만들거나 문제를 설명할 때 예제를 제공하세요. 예제는 기대치를 보여주어 문제 해결에 관련된 누구든지 또는 무엇이든지(GitHub Copilot과 같은 도구 포함)에게 작업을 더 명확하게 만들 수 있습니다.

예를 들어, 레거시 코드의 경우 작업을 수행하는 로직을 포함하면서 입력과 예상 출력이 무엇인지 설명할 수 있습니다.

> [!TIP]
> 예제 중심의 문제 해결은 이해를 일치시키는 데 도움이 됩니다. 모호한 작업에 특히 유용합니다.

### 6. 패턴 식별 및 솔루션 재사용
문제에서 공통 패턴을 인식하고 해당하는 곳에서 솔루션을 재사용하세요. 레거시 Python 프로젝트에서 이의 명백한 예는 Python 2.5의 예외 처리 사용이 Python 3+에서 `SyntaxError`를 생성하는 것입니다.

때로는 레거시 프로젝트에서 두 경우를 모두 처리하는 함수를 만들거나 Python 버전에 따라 import를 할 수 있는 모듈을 만드는 것이 일반적입니다. 이는 다른 프로젝트에서 재사용할 수 있는 레거시 프로젝트의 일반적인 패턴입니다.

> [!TIP]
> 패턴 인식은 경험의 특징입니다. 유사한 문제를 반복적으로 접하게 되면 프로세스를 가속화할 수 있는 유사점을 보기 시작할 것입니다.

### 7. 견고성을 위한 제약 조건 및 엣지 케이스 사용
엣지 케이스와 예외에 대해 생각해보세요. 복잡한 문제는 종종 "이상적인" 데이터뿐만 아니라 순진한 솔루션을 깨뜨릴 수 있는 "엣지" 또는 "아웃라이어" 케이스를 처리하는 것을 포함합니다. 프롬프트나 솔루션이 이러한 엣지 케이스를 고려하는지 확인하세요.

레거시 코드에서 이는 예상치 못한 입력으로 코드가 어떻게 동작하는지 고려하는 것을 의미할 수 있으며, 이는 새로운 테스트를 작성하거나 기존 테스트를 수정하도록 안내할 것입니다.

> [!TIP]
> 엣지 케이스를 생각하는 것은 더 탄력적이고 일반화된 솔루션을 구축하는 데 도움이 됩니다. 변경 사항을 검증하기 위한 견고한 테스트 스위트를 만드는 테스트와 생성에 항상 추가적인 강조를 두세요.

### 8. 도구 효과적으로 사용
GitHub Copilot, 편집기 자동 완성 또는 다른 형태의 자동화를 사용하든 상관없이 마음대로 사용할 수 있는 도구를 활용하되 올바른 맥락으로 안내하고 있는지 확인하세요. 도구는 생성 속도를 높이는 데 훌륭하지만 여전히 구조화된 입력과 당신의 검증이 필요합니다.

GitHub Copilot의 경우 프롬프트가 상세하지만 간결한지 확인하세요. 도구는 모호함을 거의 남기지 않는 구조화된 입력을 제공받을 때 가장 잘 작동하는 경우가 많습니다.

> [!TIP]
> 도구에 구체적이되 결과도 확인하세요. 도구가 적절히 안내되지 않으면 맥락을 완전히 이해하지 못할 수 있습니다.

### 9. 테스트 및 검증
테스트와 검증은 솔루션이 예상대로 작동하는지 확인하는 핵심입니다. 레거시 코드의 경우 새로운 코드가 기존 코드와 유사하게(또는 정확히 동일하게) 동작하는지 확인하려고 하므로 이는 더욱 중요합니다.

테스트는 예상된 상황과 예상치 못한 상황 모두 올바르게 처리되는지 확인합니다.

> [!TIP]
> 실수를 조기에 발견하기 위해 프로세스에 검증 단계를 항상 포함하세요.

다른 사용 사례에 대한 일반화:
코드나 알고리즘 작성의 경우: 함수, 클래스 또는 워크플로우를 생성할 때 동일한 개념이 적용됩니다. 입력, 예상 출력, 엣지 케이스를 명확히 정의하고 개선을 위해 반복하세요.

AI 모델 프롬프트의 경우: 복잡한 것(코드, 텍스트 또는 디자인 생성과 같은)을 요청할 때 명확한 목표를 제공하고, 문제를 분해하고, 맥락을 제공하고, 피드백을 기반으로 반복하세요.

디자인이나 콘텐츠 생성의 경우: 목적을 정의하고, 디자인 요소를 분해하고, 예제나 영감을 제공한 다음 피드백을 기반으로 개선하세요.

최종 생각:
복잡한 생성 문제는 종종 명확성, 분해, 반복 및 검증의 균형을 포함합니다. SQL 쿼리든 다른 작업이든 이러한 개념을 염두에 두면 더 정확하고 효율적이며 신뢰할 수 있는 결과를 생성할 수 있습니다.

## :books: 리소스

필수는 아니지만, 이 워크샵에서 다루는 일부 기능은 다음 Microsoft Learning 모듈에 있습니다:

- [GitHub Codespaces로 코드 작성](https://learn.microsoft.com/training/modules/code-with-github-codespaces/)
- [고급 GitHub Copilot 기능 사용](https://learn.microsoft.com/training/modules/advanced-github-copilot/)

## 기여

이 프로젝트는 기여와 제안을 환영합니다. 대부분의 기여는 기여자 라이선스 계약(CLA)에 동의하여 기여할 권리가 있으며 실제로 기여를 사용할 권리를 우리에게 부여한다고 선언해야 합니다. 자세한 내용은 https://cla.opensource.microsoft.com을 방문하세요.

풀 리퀘스트를 제출하면 CLA 봇이 자동으로 CLA를 제공해야 하는지 판단하고 PR을 적절히 꾸밉니다(예: 상태 확인, 댓글). 봇이 제공하는 지침을 따르기만 하면 됩니다. 우리 CLA를 사용하는 모든 리포지토리에서 한 번만 하면 됩니다.

이 프로젝트는 [Microsoft 오픈 소스 행동 강령](https://opensource.microsoft.com/codeofconduct/)을 채택했습니다.
자세한 정보는 [행동 강령 FAQ](https://opensource.microsoft.com/codeofconduct/faq/)를 참조하거나
추가 질문이나 댓글이 있으면 [opencode@microsoft.com](mailto:opencode@microsoft.com)에 문의하세요.

## 상표

이 프로젝트에는 프로젝트, 제품 또는 서비스에 대한 상표 또는 로고가 포함될 수 있습니다. Microsoft 상표 또는 로고의 승인된 사용은
[Microsoft의 상표 및 브랜드 가이드라인](https://www.microsoft.com/en-us/legal/intellectualproperty/trademarks/usage/general)의 적용을 받고 이를 따라야 합니다.
이 프로젝트의 수정된 버전에서 Microsoft 상표 또는 로고를 사용하는 것은 혼란을 야기하거나 Microsoft 후원을 암시해서는 안 됩니다.
제3자 상표 또는 로고의 사용은 해당 제3자의 정책을 따릅니다.